"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
describe('Block Utilities', () => {
    test('extractBlockHeader returns first 80 bytes (160 hex chars)', () => {
        const mockBlockHex = '0'.repeat(200);
        const header = (0, index_1.extractBlockHeader)(mockBlockHex);
        expect(header).toBe('0'.repeat(160));
    });
    test('getTxHashes converts transaction IDs to internal byte order', () => {
        const mockBlock = {
            tx: [
                { txid: 'ab'.repeat(32) },
                { txid: 'cd'.repeat(32) }
            ]
        };
        const hashes = (0, index_1.getTxHashes)(mockBlock);
        expect(hashes).toHaveLength(2);
        expect(hashes[0]).toBeInstanceOf(Buffer);
        expect(hashes[0].length).toBe(32);
        // Check that the hash is reversed (internal byte order)
        const originalFirstHash = Buffer.from(mockBlock.tx[0].txid, 'hex');
        expect(hashes[0].toString('hex')).not.toBe(originalFirstHash.toString('hex'));
        expect(Buffer.from(hashes[0].toString('hex'), 'hex').reverse().toString('hex'))
            .toBe(mockBlock.tx[0].txid);
    });
    test('getTxHashes handles empty block', () => {
        const mockBlock = { tx: [] };
        const hashes = (0, index_1.getTxHashes)(mockBlock);
        expect(hashes).toHaveLength(0);
    });
    test('getTxHashes handles single transaction block', () => {
        const mockBlock = {
            tx: [{ txid: 'ab'.repeat(32) }]
        };
        const hashes = (0, index_1.getTxHashes)(mockBlock);
        expect(hashes).toHaveLength(1);
        expect(hashes[0]).toBeInstanceOf(Buffer);
        expect(hashes[0].length).toBe(32);
    });
});
