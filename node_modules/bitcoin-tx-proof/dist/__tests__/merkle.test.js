"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const merkle_1 = require("../merkle");
describe('Merkle Tree Calculations', () => {
    // Using real Bitcoin transaction hex from testnet
    const sampleTx1 = '020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403a08601feffffff0200f2052a010000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000';
    const sampleTx2 = '020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff0403a08601feffffff0200f2052a010000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac0000000000000000266a24aa21a9ede2f61c3f71d1defd3fa999dfa36953755c690689799962b48bebd836974e8cf90120000000000000000000000000000000000000000000000000000000000000000000000000';
    test('calculateWTXID returns correct hash for non-witness tx', () => {
        const result = (0, merkle_1.calculateWTXID)(sampleTx1);
        expect(result.toString('hex')).toHaveLength(64);
    });
    test('calculateWTXID returns correct hash for witness tx', () => {
        const result = (0, merkle_1.calculateWTXID)(sampleTx2);
        expect(result.toString('hex')).toHaveLength(64);
    });
    test('calculateMerkleRoot works with empty array', () => {
        const result = (0, merkle_1.calculateMerkleRoot)([]);
        expect(result.length).toBe(32);
        expect(result.equals(Buffer.alloc(32, 0))).toBe(true);
    });
    test('calculateMerkleRoot works with single transaction', () => {
        const tx1Hash = Buffer.from('a'.repeat(64), 'hex');
        const result = (0, merkle_1.calculateMerkleRoot)([tx1Hash]);
        expect(result.equals(tx1Hash)).toBe(true);
    });
    test('calculateMerkleRoot works with odd number of transactions', () => {
        const tx1Hash = Buffer.from('a'.repeat(64), 'hex');
        const tx2Hash = Buffer.from('b'.repeat(64), 'hex');
        const tx3Hash = Buffer.from('c'.repeat(64), 'hex');
        const result = (0, merkle_1.calculateMerkleRoot)([tx1Hash, tx2Hash, tx3Hash]);
        expect(result.length).toBe(32);
    });
    test('getMerkleProof generates valid proof', () => {
        const tx1Hash = Buffer.from('a'.repeat(64), 'hex'); // Using dummy hash
        const tx2Hash = Buffer.from('b'.repeat(64), 'hex'); // Using dummy hash
        const proof = (0, merkle_1.getMerkleProof)([tx1Hash, tx2Hash], 0);
        expect(proof.length).toBe(1);
        expect(proof[0].data.equals(tx2Hash)).toBe(true);
        expect(proof[0].position).toBe('right');
    });
    test('getMerkleProof handles odd number of transactions', () => {
        const tx1Hash = Buffer.from('a'.repeat(64), 'hex');
        const tx2Hash = Buffer.from('b'.repeat(64), 'hex');
        const tx3Hash = Buffer.from('c'.repeat(64), 'hex');
        const proof = (0, merkle_1.getMerkleProof)([tx1Hash, tx2Hash, tx3Hash], 0);
        expect(proof.length).toBe(2);
    });
    test('getMerkleProof handles last transaction in odd-numbered list', () => {
        const tx1Hash = Buffer.from('a'.repeat(64), 'hex');
        const tx2Hash = Buffer.from('b'.repeat(64), 'hex');
        const tx3Hash = Buffer.from('c'.repeat(64), 'hex');
        const proof = (0, merkle_1.getMerkleProof)([tx1Hash, tx2Hash, tx3Hash], 2);
        expect(proof.length).toBe(2);
    });
    test('verifies merkle proof correctly', () => {
        const tx1Hash = Buffer.from('a'.repeat(64), 'hex');
        const tx2Hash = Buffer.from('b'.repeat(64), 'hex');
        const proof = (0, merkle_1.getMerkleProof)([tx1Hash, tx2Hash], 0);
        const root = (0, merkle_1.calculateMerkleRoot)([tx1Hash, tx2Hash]);
        expect((0, merkle_1.verifyMerkleProof)(tx1Hash, proof, root)).toBe(true);
    });
    test('verifyMerkleProof fails with invalid proof', () => {
        const tx1Hash = Buffer.from('a'.repeat(64), 'hex');
        const tx2Hash = Buffer.from('b'.repeat(64), 'hex');
        const invalidProof = (0, merkle_1.getMerkleProof)([tx1Hash, tx2Hash], 0);
        const invalidRoot = Buffer.from('d'.repeat(64), 'hex');
        expect(() => (0, merkle_1.verifyMerkleProof)(tx1Hash, invalidProof, invalidRoot))
            .toThrow('Merkle proof verification failed');
    });
    test('verifyMerkleProof works with multiple levels', () => {
        const txHashes = Array(4).fill(0).map((_, i) => Buffer.from((i + 1).toString().padStart(64, 'a'), 'hex'));
        const proof = (0, merkle_1.getMerkleProof)(txHashes, 0);
        const root = (0, merkle_1.calculateMerkleRoot)(txHashes);
        expect((0, merkle_1.verifyMerkleProof)(txHashes[0], proof, root)).toBe(true);
    });
});
