"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const rpc_1 = require("../rpc");
const merkle_1 = require("../merkle");
// Mock the BitcoinRPC class
jest.mock('../rpc');
const MockedBitcoinRPC = rpc_1.BitcoinRPC;
describe('Bitcoin Transaction Proof', () => {
    const mockConfig = {
        url: 'http://localhost:8332',
        username: 'user',
        password: 'pass'
    };
    beforeEach(() => {
        jest.clearAllMocks();
    });
    test('generates valid proof for a real Bitcoin transaction', async () => {
        // Using data from Bitcoin block 170 - First ever Bitcoin transaction from Satoshi to Hal Finney
        const mockBlockHash = '00000000d1145790a8694403d4063f323d499e655c83426834d4ce2f8dd4a2ee';
        const mockTxId = 'f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16';
        const mockBlock = {
            hash: mockBlockHash,
            height: 170,
            version: 1,
            merkleroot: '7dac2c5666815c17a3b36427de37bb9d2e2c5ccec3f8633eb91a4205cb4c10ff',
            tx: [
                {
                    txid: 'b1fea52486ce0c62bb442b530a3f0132b826c74e473d1f2c220bfa78111c5082',
                    hex: '01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0704ffff001d0104ffffffff0100f2052a01000000434104e70a02f5af48a1989bf630d92523c9d14c45c75f7d1b998e962bff6ff9995fc5bdb44f1793b37495d80324acba7c8f537caaf8432b8d47987313060cc82d8a93ac00000000'
                },
                {
                    txid: mockTxId,
                    hex: '0100000001c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25857fcd3704000000004847304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d0901ffffffff0200ca9a3b00000000434104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302fa28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e6cd84cac00286bee0000000043410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac00000000'
                }
            ],
            time: 1231731025,
            nonce: 1889418792,
            bits: '1d00ffff'
        };
        // Mock RPC responses
        MockedBitcoinRPC.prototype.call.mockImplementation(async (method, params) => {
            switch (method) {
                case 'getblockhash':
                    return mockBlockHash;
                case 'getblock':
                    if (params[1] === 2)
                        return mockBlock;
                    if (params[1] === 0)
                        return '0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c';
                case 'getrawtransaction':
                    return mockBlock.tx.find(tx => tx.txid === params[0]);
                default:
                    throw new Error(`Unexpected method: ${method}`);
            }
        });
        const result = await (0, index_1.bitcoinTxProof)(mockTxId, 170, mockConfig);
        // 1. Verify basic properties
        expect(result.blockHeight).toBe(170);
        expect(result.transaction).toBe(mockBlock.tx[1].hex);
        expect(result.txIndex).toBe(1);
        expect(result.merkleProofDepth).toBe(1); // ceil(log2(2))
        // 2. Verify block header format (80 bytes = 160 hex chars)
        expect(result.blockHeader).toHaveLength(160);
        expect(result.blockHeader).toMatch(/^[0-9a-f]{160}$/);
        // 3. Verify coinbase transaction
        expect(result.coinbaseTransaction).toBe(mockBlock.tx[0].hex);
        // 4. Verify merkle proof
        // The proof should be a concatenation of 32-byte hashes
        expect(result.coinbaseMerkleProof.length % 64).toBe(0); // Each hash is 32 bytes = 64 hex chars
        // Convert hex proof to steps for verification
        const proofSteps = [];
        for (let i = 0; i < result.coinbaseMerkleProof.length; i += 64) {
            const hashHex = result.coinbaseMerkleProof.slice(i, i + 64);
            proofSteps.push({
                data: Buffer.from(hashHex, 'hex'),
                position: i === 0 ? 'left' : 'right'
            });
        }
        // Verify that the merkle proof is valid
        const isValid = (0, merkle_1.verifyMerkleProof)(mockTxId, proofSteps, mockBlock.merkleroot);
        expect(isValid).toBe(true);
        // 5. Verify witness data
        // For this historical transaction, there should be no witness data
        expect(result.witnessMerkleProof).toBe('');
        expect(result.witnessReservedValue).toBe('0'.repeat(64));
    });
    test('generates valid proof for a block with more than two transactions', async () => {
        // Using data from a more recent block with multiple transactions
        const mockBlockHash = '000000000000000000000000000000000000000000000000000000000000000a';
        const mockTxId = 'transaction3';
        const mockBlock = {
            hash: mockBlockHash,
            height: 500000,
            merkleroot: 'merkleroot',
            tx: Array(5).fill(0).map((_, i) => ({
                txid: `transaction${i + 1}`,
                hex: `transaction${i + 1}hex`
            }))
        };
        MockedBitcoinRPC.prototype.call.mockImplementation(async (method, params) => {
            switch (method) {
                case 'getblockhash':
                    return mockBlockHash;
                case 'getblock':
                    if (params[1] === 2)
                        return mockBlock;
                    if (params[1] === 0)
                        return '0'.repeat(160);
                case 'getrawtransaction':
                    return mockBlock.tx.find(tx => tx.txid === params[0]);
                default:
                    throw new Error(`Unexpected method: ${method}`);
            }
        });
        const result = await (0, index_1.bitcoinTxProof)(mockTxId, 500000, mockConfig);
        // Basic validations
        expect(result.blockHeight).toBe(500000);
        expect(result.transaction).toBe('transaction3hex');
        expect(result.txIndex).toBe(2); // 0-based index
        expect(result.merkleProofDepth).toBe(3); // ceil(log2(5))
        // Merkle proof should have the correct number of steps
        const numHashes = result.coinbaseMerkleProof.length / 64;
        expect(numHashes).toBe(3); // For a tree with 5 transactions, we need 3 hashes to prove position 2
    });
    test('handles witness transactions correctly', async () => {
        const mockBlockHash = '000000000000000000000000000000000000000000000000000000000000000b';
        const mockTxId = 'witness_tx';
        const mockBlock = {
            hash: mockBlockHash,
            height: 500001,
            merkleroot: 'merkleroot',
            tx: [
                {
                    txid: 'coinbase',
                    hex: 'coinbasehex',
                    vin: [{ coinbase: '0' }]
                },
                {
                    txid: mockTxId,
                    hex: '02000000000101...', // Starts with 0x02 to indicate witness tx
                    vin: [{ txinwitness: ['witness', 'data'] }]
                }
            ]
        };
        MockedBitcoinRPC.prototype.call.mockImplementation(async (method, params) => {
            switch (method) {
                case 'getblockhash':
                    return mockBlockHash;
                case 'getblock':
                    if (params[1] === 2)
                        return mockBlock;
                    if (params[1] === 0)
                        return '0'.repeat(160);
                case 'getrawtransaction':
                    return mockBlock.tx.find(tx => tx.txid === params[0]);
                default:
                    throw new Error(`Unexpected method: ${method}`);
            }
        });
        const result = await (0, index_1.bitcoinTxProof)(mockTxId, 500001, mockConfig);
        // For a witness transaction, we should have a witness merkle proof
        expect(result.witnessMerkleProof).not.toBe('');
        expect(result.witnessMerkleProof.length % 64).toBe(0); // Should be multiple of 32 bytes
    });
    test('throws error when transaction not found in block', async () => {
        const mockBlockHash = '000000000000000000000000000000000000000000000000000000000000000c';
        const mockBlock = {
            hash: mockBlockHash,
            height: 500002,
            merkleroot: 'merkleroot',
            tx: [{ txid: 'other_tx', hex: 'othertxhex' }]
        };
        MockedBitcoinRPC.prototype.call.mockImplementation(async (method, params) => {
            switch (method) {
                case 'getblockhash':
                    return mockBlockHash;
                case 'getblock':
                    return mockBlock;
                default:
                    throw new Error(`Unexpected method: ${method}`);
            }
        });
        await expect((0, index_1.bitcoinTxProof)('nonexistent_tx', 500002, mockConfig)).rejects.toThrow('Transaction not found in block');
    });
});
