import { cvToHex, deserializeCV, } from '@stacks/transactions';
import { assert } from '../common/assert.js';
import { kDefaultStacksReadRetries, kDefaultStacksTimeout, } from '../common/constants.js';
import { exponentialBackoff, retryOnError, richFetch, } from '../common/fetch.js';
import { fromUint8Array } from '../utils/buffer.js';
import { decodeAbi, encodeAbi } from './abi-codec.js';
import { kDefaultStacksEndpoint } from './constants.js';
export async function callReadonly(params) {
    const stacksEndpoint = params.stacksEndpoint ?? kDefaultStacksEndpoint;
    const urlParams = new URLSearchParams();
    if (typeof params.indexBlockHash === 'string') {
        urlParams.set('tip', params.indexBlockHash.substring(2).toLowerCase());
    }
    else if (params.indexBlockHash instanceof Uint8Array) {
        urlParams.set('tip', fromUint8Array(params.indexBlockHash).toString('hex'));
    }
    const [deployer, contractName] = params.contract.split('.', 2);
    const fn = String(params.functionName);
    const args = [];
    const functionDef = params.abi.find((def) => def.name === params.functionName);
    assert(functionDef != null, `failed to find function definition for ${params.functionName}`);
    const argsKV = params.args;
    for (const argDef of functionDef.args) {
        args.push(encodeAbi(argDef.type, argsKV[argDef.name]));
    }
    const url = `${stacksEndpoint}/v2/contracts/call-read/${deployer}/${contractName}/${fn}?${urlParams.toString()}`;
    const body = JSON.stringify({
        sender: params.sender ?? deployer,
        arguments: args.map(cvToHex),
    });
    const funcResponse = await richFetch(url, {
        method: 'POST',
        body,
        headers: { 'Content-Type': 'application/json' },
        fetch: params.fetch,
        timeout: params.timeout ?? kDefaultStacksTimeout,
        retries: params.retries ?? kDefaultStacksReadRetries,
        retryDelay: params.retryDelay ?? exponentialBackoff(),
        retryOn: retryOnError,
    });
    if (funcResponse.status !== 200) {
        throw new Error(`Readonly call failed with http code ${funcResponse.status}: ${funcResponse.statusText}`);
    }
    const funcResult = await funcResponse.json();
    if (funcResult.okay !== true) {
        throw new Error(`Readonly call failed with error: ${funcResult.cause}`);
    }
    const result = deserializeCV(funcResult.result);
    return decodeAbi(functionDef.outputs.type, result);
}
export function unwrapResponse(response) {
    if (response.type === 'success') {
        return response.value;
    }
    throw new Error(`Clarity ResponseErr: ${response.error}`);
}
//# sourceMappingURL=call-readonly.js.map