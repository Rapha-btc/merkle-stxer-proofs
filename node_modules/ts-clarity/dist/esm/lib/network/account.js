import { retryOnError, richFetch } from '../common/fetch.js';
import { mergeDefaultExtendedApiRequestOptions, mergeDefaultNodeApiRequestOptions, } from './request.js';
export async function getAccountInfo(address, _options) {
    const options = mergeDefaultNodeApiRequestOptions(_options);
    const url = `${options.stacksEndpoint}/v2/accounts/${address}?proof=${_options?.proof === true ? 1 : 0}`;
    const rs = await richFetch(url, {
        timeout: options.timeout,
        fetch: options.fetch,
        retries: options.retries,
        retryDelay: options.retryDelay,
        retryOn: retryOnError,
    });
    const result = await rs.json();
    // safe-guard to ensure stacks api returns proper response
    if (typeof result.nonce !== 'number' || !(result.nonce >= 0)) {
        throw new Error(`Unexpected account nonce response: ${JSON.stringify(result)}`);
    }
    result.balance = BigInt(result.balance);
    result.locked = BigInt(result.locked);
    return result;
}
export async function getAccountNonces(address, _options) {
    const options = mergeDefaultExtendedApiRequestOptions(_options);
    const url = `${options.stacksEndpoint}/extended/v1/address/${address}/nonces`;
    const rs = await richFetch(url, {
        timeout: options.timeout,
        fetch: options.fetch,
        retries: options.retries,
        retryDelay: options.retryDelay,
        retryOn: retryOnError,
    });
    const nonces = await rs.json();
    // safe-guard to ensure stacks api returns proper response
    if (typeof nonces.possible_next_nonce !== 'number' ||
        !(nonces.possible_next_nonce >= 0)) {
        throw new Error(`Unexpected account nonce response: ${JSON.stringify(nonces)}`);
    }
    if (nonces.last_executed_tx_nonce == null)
        nonces.last_executed_tx_nonce = -1;
    if (nonces.last_mempool_tx_nonce == null)
        nonces.last_mempool_tx_nonce = -1;
    if (!Array.isArray(nonces.detected_missing_nonces))
        nonces.detected_missing_nonces = [];
    return nonces;
}
export async function getAccountBalances(address, _options) {
    const options = mergeDefaultExtendedApiRequestOptions(_options);
    const url = `${options.stacksEndpoint}/extended/v1/address/${address}/balances`;
    const rs = await richFetch(url, {
        timeout: options.timeout,
        fetch: options.fetch,
        retries: options.retries,
        retryDelay: options.retryDelay,
        retryOn: retryOnError,
    });
    const result = await rs.json();
    const balances = {
        stx: {
            balance: BigInt(result.stx.balance),
            total_sent: BigInt(result.stx.total_sent),
            total_received: BigInt(result.stx.total_received),
            total_fees_sent: BigInt(result.stx.total_fees_sent),
            total_miner_rewards_received: BigInt(result.stx.total_miner_rewards_received),
            lock_tx_id: result.stx.lock_tx_id,
            locked: BigInt(result.stx.locked),
            lock_height: result.stx.lock_height,
            burnchain_lock_height: result.stx.burnchain_lock_height,
            burnchain_unlock_height: result.stx.burnchain_unlock_height,
        },
        fungible_tokens: {},
        non_fungible_tokens: {},
    };
    for (const [k, v] of Object.entries(result.fungible_tokens)) {
        if (v == null)
            continue;
        balances.fungible_tokens[k] = {
            balance: BigInt(v.balance),
            total_received: BigInt(v.total_received),
            total_sent: BigInt(v.total_sent),
        };
    }
    for (const [k, v] of Object.entries(result.non_fungible_tokens)) {
        if (v == null)
            continue;
        balances.non_fungible_tokens[k] = {
            count: BigInt(v.count),
            total_received: BigInt(v.total_received),
            total_sent: BigInt(v.total_sent),
        };
    }
    if (result.token_offering_locked != null) {
        balances.token_offering_locked = {
            total_locked: BigInt(result.token_offering_locked.total_locked),
            total_unlocked: BigInt(result.token_offering_locked.total_unlocked),
            unlock_schedule: result.token_offering_locked.unlock_schedule.map((schedule) => ({
                amount: BigInt(schedule.amount),
                block_height: schedule.block_height,
            })),
        };
    }
    return balances;
}
//# sourceMappingURL=account.js.map