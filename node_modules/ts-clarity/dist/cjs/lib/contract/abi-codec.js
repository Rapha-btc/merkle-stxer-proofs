"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeAbi = encodeAbi;
exports.decodeAbi = decodeAbi;
const transactions_1 = require("@stacks/transactions");
const clarity_abi_1 = require("clarity-abi");
const assert_js_1 = require("../common/assert.js");
const buffer_js_1 = require("../utils/buffer.js");
function assertNever(v) {
    throw new Error(`unexpected value: ${v}`);
}
function encodeAbi(abi, value) {
    if ((0, clarity_abi_1.isClarityAbiPrimitive)(abi)) {
        switch (abi) {
            case 'uint128':
                (0, assert_js_1.assert)(typeof value === 'bigint');
                return {
                    type: transactions_1.ClarityType.UInt,
                    value,
                };
            case 'int128':
                (0, assert_js_1.assert)(typeof value === 'bigint');
                return {
                    type: transactions_1.ClarityType.Int,
                    value,
                };
            case 'bool':
                (0, assert_js_1.assert)(typeof value === 'boolean');
                return {
                    type: value ? transactions_1.ClarityType.BoolTrue : transactions_1.ClarityType.BoolFalse,
                };
            case 'none':
                (0, assert_js_1.assert)(value == null);
                return {
                    type: transactions_1.ClarityType.OptionalNone,
                };
            case 'principal':
                (0, assert_js_1.assert)(typeof value === 'string');
                if (value.includes('.')) {
                    const [address, contractName] = value.split('.');
                    (0, assert_js_1.assert)(address != null && contractName != null);
                    return (0, transactions_1.contractPrincipalCV)(address, contractName);
                }
                return (0, transactions_1.standardPrincipalCV)(value);
            case 'trait_reference': {
                (0, assert_js_1.assert)(typeof value === 'string');
                (0, assert_js_1.assert)(value.includes('.'));
                const [address, contractName] = value.split('.');
                (0, assert_js_1.assert)(address != null && contractName != null);
                return (0, transactions_1.contractPrincipalCV)(address, contractName);
            }
            default:
                assertNever(abi);
        }
    }
    if ((0, clarity_abi_1.isClarityAbiStringAscii)(abi)) {
        (0, assert_js_1.assert)(typeof value === 'string');
        return {
            type: transactions_1.ClarityType.StringASCII,
            value,
        };
    }
    if ((0, clarity_abi_1.isClarityAbiStringUtf8)(abi)) {
        (0, assert_js_1.assert)(typeof value === 'string');
        return {
            type: transactions_1.ClarityType.StringUTF8,
            value,
        };
    }
    if ((0, clarity_abi_1.isClarityAbiTuple)(abi)) {
        (0, assert_js_1.assert)(value != null && typeof value === 'object');
        const kv = value;
        const tuple = {
            type: transactions_1.ClarityType.Tuple,
            value: {},
        };
        for (const def of abi.tuple) {
            const v = kv[def.name];
            tuple.value[def.name] = encodeAbi(def.type, v);
        }
        return tuple;
    }
    if ((0, clarity_abi_1.isClarityAbiResponse)(abi)) {
        const response = value;
        (0, assert_js_1.assert)(response.type === 'success' || response.type === 'error');
        if (response.type === 'success') {
            return {
                type: transactions_1.ClarityType.ResponseOk,
                value: encodeAbi(abi.response.ok, response.value),
            };
        }
        return {
            type: transactions_1.ClarityType.ResponseErr,
            value: encodeAbi(abi.response.error, response.value),
        };
    }
    if ((0, clarity_abi_1.isClarityAbiBuffer)(abi)) {
        (0, assert_js_1.assert)(value instanceof Uint8Array);
        return {
            type: transactions_1.ClarityType.Buffer,
            value: (0, buffer_js_1.fromUint8Array)(value).toString('hex'),
        };
    }
    if ((0, clarity_abi_1.isClarityAbiList)(abi)) {
        (0, assert_js_1.assert)(Array.isArray(value));
        return {
            type: transactions_1.ClarityType.List,
            value: value.map((item) => encodeAbi(abi.list.type, item)),
        };
    }
    if ((0, clarity_abi_1.isClarityAbiOptional)(abi)) {
        if (value == null) {
            return {
                type: transactions_1.ClarityType.OptionalNone,
            };
        }
        return {
            type: transactions_1.ClarityType.OptionalSome,
            value: encodeAbi(abi.optional, value),
        };
    }
    assertNever(abi);
}
function decodeAbi(_abi, cv) {
    const abi = _abi;
    if ((0, clarity_abi_1.isClarityAbiPrimitive)(abi)) {
        switch (abi) {
            case 'uint128':
                (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.UInt);
                return cv.value;
            case 'int128':
                (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.Int);
                return cv.value;
            case 'bool':
                (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.BoolFalse || cv.type === transactions_1.ClarityType.BoolTrue);
                return (cv.type ===
                    transactions_1.ClarityType.BoolTrue);
            case 'none':
                (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.OptionalNone);
                return null;
            case 'principal':
                (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.PrincipalStandard ||
                    cv.type === transactions_1.ClarityType.PrincipalContract);
                if (cv.type === transactions_1.ClarityType.PrincipalStandard) {
                    return cv.value;
                }
                return cv.value;
            case 'trait_reference':
                (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.PrincipalContract);
                return cv.value;
            default:
                assertNever(abi);
        }
    }
    if ((0, clarity_abi_1.isClarityAbiStringAscii)(abi)) {
        (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.StringASCII);
        return cv.value;
    }
    if ((0, clarity_abi_1.isClarityAbiStringUtf8)(abi)) {
        (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.StringUTF8);
        return cv.value;
    }
    if ((0, clarity_abi_1.isClarityAbiTuple)(abi)) {
        (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.Tuple);
        const tuple = {};
        for (const def of abi.tuple) {
            const v = cv.value[def.name];
            (0, assert_js_1.assert)(v != null);
            tuple[def.name] = decodeAbi(def.type, v);
        }
        return tuple;
    }
    if ((0, clarity_abi_1.isClarityAbiResponse)(abi)) {
        (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.ResponseOk || cv.type === transactions_1.ClarityType.ResponseErr);
        if (cv.type === transactions_1.ClarityType.ResponseOk) {
            return {
                type: 'success',
                value: decodeAbi(abi.response.ok, cv.value),
            };
        }
        return {
            type: 'error',
            error: decodeAbi(abi.response.error, cv.value),
        };
    }
    if ((0, clarity_abi_1.isClarityAbiBuffer)(abi)) {
        (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.Buffer);
        return Buffer.from(cv.value, 'hex');
    }
    if ((0, clarity_abi_1.isClarityAbiList)(abi)) {
        (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.List);
        return cv.value.map((item) => decodeAbi(abi.list.type, item));
    }
    if ((0, clarity_abi_1.isClarityAbiOptional)(abi)) {
        (0, assert_js_1.assert)(cv.type === transactions_1.ClarityType.OptionalNone ||
            cv.type === transactions_1.ClarityType.OptionalSome);
        if (cv.type === transactions_1.ClarityType.OptionalNone) {
            return null;
        }
        return decodeAbi(abi.optional, cv.value);
    }
    assertNever(abi);
}
//# sourceMappingURL=abi-codec.js.map