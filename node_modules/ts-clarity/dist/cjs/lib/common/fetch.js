"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exponentialBackoff = exponentialBackoff;
exports.retryOnError = retryOnError;
exports.richFetch = richFetch;
const cross_fetch_1 = require("cross-fetch");
const kDefaultRequestTimeout = 60_000;
function exponentialBackoff(initDelay = 1000, maxDelay = 60_0000) {
    return (attempt) => {
        return Math.min(maxDelay, 2 ** attempt * initDelay);
    };
}
function retryOnError(_attempt, error, response) {
    if (error != null)
        return true;
    if (response != null) {
        if (response.status === 429 || response.status >= 500)
            return true;
    }
    return false;
}
function throwWithStackTrace(e) {
    if (e instanceof Error) {
        e.stack += `\n${new Error().stack}`;
    }
    throw e;
}
async function richFetch(url, options) {
    const doFetch = options?.fetch ?? cross_fetch_1.default;
    const timeout = options?.timeout ?? kDefaultRequestTimeout;
    const retries = options?.retries ?? 1;
    const retryDelay = typeof options?.retryDelay === 'function'
        ? options.retryDelay
        : () => typeof options?.retryDelay === 'number' ? options.retryDelay : 0;
    const retryOn = typeof options?.retryOn === 'function'
        ? options.retryOn
        : (_, _err, response) => Array.isArray(options?.retryOn) &&
            response != null &&
            options.retryOn.includes(response.status);
    const timeoutError = new Error(`request timeout after ${timeout}ms`);
    for (let attempt = 0; attempt < retries; attempt++) {
        const abortController = new AbortController();
        let timer = setTimeout(() => abortController.abort(timeoutError), timeout);
        const onCancel = (e) => abortController.abort(e);
        if (options?.signal != null) {
            options.signal.addEventListener('abort', onCancel);
        }
        let response = null;
        try {
            response = await doFetch(url, {
                ...options,
                signal: abortController.signal,
            });
            if (await retryOn(attempt, null, response)) {
                const delay = retryDelay(attempt, null, response);
                await new Promise((f) => setTimeout(f, delay));
                continue;
            }
            return response;
        }
        catch (e) {
            if (attempt + 1 >= retries)
                throwWithStackTrace(e);
            if (await retryOn(attempt, e, response)) {
                const delay = retryDelay(attempt, e, response);
                await new Promise((f) => setTimeout(f, delay));
                continue;
            }
            throwWithStackTrace(e);
        }
        finally {
            clearTimeout(timer);
            timer = null;
        }
    }
    throw new Error(`Request failed after ${retries} attempts.`);
}
//# sourceMappingURL=fetch.js.map